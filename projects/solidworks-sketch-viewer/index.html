<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SolidWorks Sketch Viewer Test | kuemmerle.dev</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #0f1115;
      --panel: #141824;
      --panel2: #10131b;
      --text: #e9e9ef;
      --muted: rgba(233,233,239,0.7);
      --stroke: rgba(233,233,239,0.14);
      --accent: #3a7bfd;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      background:
        radial-gradient(130% 120% at 0% 0%, rgba(58,123,253,0.14), transparent 62%),
        linear-gradient(180deg, var(--panel2), var(--bg));
      color: var(--text);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    .viewerTopbar {
      padding: 0.75rem 1rem;
      background: linear-gradient(180deg, rgba(16,19,27,0.96), rgba(16,19,27,0.82));
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      border-bottom: 1px solid var(--stroke);
      backdrop-filter: blur(6px);
    }

    .viewerBrand {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      min-width: 0;
    }

    .viewerBack {
      width: fit-content;
      color: rgba(200,220,255,0.9);
      text-decoration: none;
      border-bottom: 1px solid rgba(200,220,255,0.35);
      font-size: 0.82rem;
      line-height: 1.1;
    }

    .viewerBack:hover {
      color: #fff;
      border-bottom-color: rgba(200,220,255,0.85);
    }

    .viewerTopbar h1 {
      font-size: 1rem;
      margin: 0;
      font-weight: 800;
      letter-spacing: 0.02em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .viewerNav{
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .viewerNav a{
      color: var(--muted);
      text-decoration: none;
      font-weight: 600;
      padding: 0.3rem 0.55rem;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 0.82rem;
    }

    .viewerNav a:hover{
      color: #fff;
      border-color: var(--stroke);
      background: rgba(255,255,255,0.03);
    }

    .viewerMain {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      padding: 0.7rem;
      gap: 0.6rem;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      flex-wrap: wrap;
      padding: 0.6rem 0.7rem;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background:
        linear-gradient(180deg, rgba(16,19,27,0.92), rgba(16,19,27,0.82)),
        radial-gradient(120% 140% at 0% 0%, rgba(58,123,253,0.16), transparent 58%);
      user-select: none;
    }

    .controls label {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      white-space: nowrap;
      font-size: 0.82rem;
      color: var(--muted);
    }

    select, input[type="file"], input[type="range"]{
      font: inherit;
      color: var(--text);
      background: rgba(15,17,21,0.88);
      border: 1px solid rgba(233,233,239,0.24);
      border-radius: 8px;
      padding: 0.22rem 0.45rem;
    }

    input[type="range"]{
      padding: 0;
      height: 1.1rem;
      width: 7.5rem;
    }

    .statusChip{
      margin-left: auto;
      max-width: min(100%, 34rem);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 0.78rem;
      color: rgba(233,233,239,0.82);
      border: 1px solid rgba(233,233,239,0.18);
      border-radius: 999px;
      padding: 0.2rem 0.55rem;
      background: rgba(255,255,255,0.04);
    }

    #canvas-container {
      flex: 1;
      position: relative;
      min-height: 0;
      border: 1px solid var(--stroke);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(0,0,0,0.35);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    .legend {
      position: absolute;
      right: 0.6rem;
      top: 0.6rem;
      background: rgba(8,10,14,0.8);
      border: 1px solid rgba(233,233,239,0.16);
      border-radius: 10px;
      padding: 0.55rem 0.65rem;
      font-size: 0.72rem;
      line-height: 1.35;
      pointer-events: none;
      max-width: 18rem;
      backdrop-filter: blur(3px);
    }

    .legend-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .legend-swatch {
      width: 0.78rem;
      height: 2px;
      border-radius: 1px;
      flex: 0 0 auto;
    }

    .legend-node {
      width: 0.45rem;
      height: 0.45rem;
      border-radius: 50%;
      border: 1px solid #fff;
      box-sizing: border-box;
      flex: 0 0 auto;
    }

    .hint {
      margin-top: 0.45rem;
      color: #bbb;
    }

    .kbd {
      display: inline-block;
      padding: 1px 6px;
      border: 1px solid rgba(233,233,239,0.25);
      border-radius: 999px;
      background: rgba(255,255,255,0.05);
      margin-right: 6px;
      margin-top: 4px;
      font-size: 0.68rem;
      letter-spacing: 0.02em;
    }

    @media (max-width: 900px){
      .viewerTopbar{
        flex-direction: column;
        align-items: flex-start;
      }

      .viewerNav{
        justify-content: flex-start;
      }

      .statusChip{
        margin-left: 0;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <header class="viewerTopbar">
    <div class="viewerBrand">
      <a class="viewerBack" href="/projects/">Back to Standalone Projects</a>
      <h1>SOLIDWORKS Sketch Viewer Test</h1>
    </div>
    <nav class="viewerNav" aria-label="Primary">
      <a href="/">Home</a>
      <a href="/resume/">Resume</a>
      <a href="/contact/">Contact</a>
      <a href="/fun/">Fun</a>
    </nav>
  </header>

  <main class="viewerMain">
    <div class="controls">
      <label>
        JSON file:
        <input type="file" id="fileInput" accept=".json" />
      </label>

      <label>
        View:
        <select id="viewSelect">
          <option value="p3d" selected>3D (Perspective)</option>
          <option value="xy">Top (XY)</option>
          <option value="xz">Front (XZ)</option>
          <option value="yz">Side (YZ)</option>
        </select>
      </label>

      <label id="fovLabel" style="display:inline-flex;">
        FOV:
        <input type="range" id="fov" min="25" max="110" value="60" />
        <span id="fovVal">60</span>&deg;
      </label>

      <span id="status" class="statusChip">No file loaded</span>
    </div>

    <div id="canvas-container">
      <canvas id="viewCanvas"></canvas>
      <div class="legend">
        <div class="legend-row"><div class="legend-node"></div><span>Node</span></div>
        <div class="legend-row"><div class="legend-swatch" style="background:#00ff88"></div><span>Line beam</span></div>
        <div class="legend-row"><div class="legend-swatch" style="background:#ffaa33"></div><span>Spline beam</span></div>
        <div class="legend-row"><div class="legend-swatch" style="background:#33ddff"></div><span>Arc beam</span></div>
        <div class="legend-row"><div class="legend-swatch" style="background:#888888"></div><span>Other beam</span></div>
        <div class="hint">
          <div class="kbd">3D drag = orbit</div>
          <div class="kbd">Shift+drag = pan</div>
          <div class="kbd">Wheel = zoom</div>
          <div class="kbd">R = reset</div>
        </div>
      </div>
    </div>
  </main>

  <script>
  const fileInput = document.getElementById("fileInput");
  const viewSelect = document.getElementById("viewSelect");
  const statusEl = document.getElementById("status");
  const canvas = document.getElementById("viewCanvas");
  const ctx = canvas.getContext("2d");
  const fovEl = document.getElementById("fov");
  const fovValEl = document.getElementById("fovVal");
  const fovLabel = document.getElementById("fovLabel");

  viewSelect.value = "p3d";
  fovLabel.style.display = "inline-flex";

  // Data
  let mode = null; // "segments" or "graph"
  let segments = null; // {Start:[x,y,z], End:[x,y,z]}[]
  let graph = null;    // {nodes:[[x,y,z],...], beams:[{I,J,Type?},...]}

  // --- Simple 3D camera state ---
  const cam = {
    target: [0, 0, 0],
    yaw: 0.8,
    pitch: -0.4,
    dist: 10,
    // used for panning target in world units
    panScale: 1,
    fovDeg: 60,
  };

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function v3(x,y,z){ return [x,y,z]; }
  function add(a,b){ return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
  function sub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
  function mul(a,s){ return [a[0]*s, a[1]*s, a[2]*s]; }
  function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
  function cross(a,b){
    return [
      a[1]*b[2]-a[2]*b[1],
      a[2]*b[0]-a[0]*b[2],
      a[0]*b[1]-a[1]*b[0]
    ];
  }
  function len(a){ return Math.hypot(a[0],a[1],a[2]); }
  function norm(a){ const l = len(a) || 1; return [a[0]/l, a[1]/l, a[2]/l]; }

  function resizeCanvas() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width));
    canvas.height = Math.max(1, Math.floor(rect.height));
    render();
  }
  window.addEventListener("resize", resizeCanvas);

  // --- Load + parse JSON ---
  function loadSketchData(jsonText, sourceName) {
    try {
      const json = JSON.parse(jsonText);

      segments = null;
      graph = null;
      mode = null;

      // Old format: array of {Start, End}
      if (Array.isArray(json)) {
        const valid = json.every(seg =>
          seg &&
          Array.isArray(seg.Start) && seg.Start.length === 3 &&
          Array.isArray(seg.End) && seg.End.length === 3
        );
        if (!valid) throw new Error("Array elements must have Start[3] and End[3]");
        segments = json;
        mode = "segments";
        statusEl.textContent = `Loaded ${segments.length} segments from "${sourceName}" (segments mode)`;
      }
      // Graph format: {nodes,beams} OR {Nodes,Beams}
      else if (json && (Array.isArray(json.nodes) || Array.isArray(json.Nodes)) && (Array.isArray(json.beams) || Array.isArray(json.Beams))) {
        const nodes = json.nodes || json.Nodes;
        const beams = json.beams || json.Beams;
        const nodesOk = nodes.every(n => Array.isArray(n) && n.length === 3);
        const beamsOk = beams.every(b => b && typeof b.I === "number" && typeof b.J === "number");
        if (!nodesOk) throw new Error("nodes must be [[x,y,z], ...]");
        if (!beamsOk) throw new Error("beams must have numeric I/J indices");
        graph = { nodes, beams };
        mode = "graph";
        statusEl.textContent = `Loaded graph: ${nodes.length} nodes, ${beams.length} beams from "${sourceName}"`;
      }
      else {
        throw new Error("Unrecognized JSON structure (expected array or {nodes,beams}/{Nodes,Beams})");
      }

      // Fit camera target/dist based on bounds.
      fitCameraToData();
      resizeCanvas();
    } catch (err) {
      segments = null;
      graph = null;
      mode = null;
      statusEl.textContent = "Error: " + err.message;
      console.error(err);
      render();
    }
  }

  fileInput.addEventListener("change", event => {
    const file = event.target.files && event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = e => loadSketchData(e.target.result, file.name);
    reader.onerror = err => {
      statusEl.textContent = "File read error";
      console.error(err);
    };
    reader.readAsText(file);
  });

  fetch("./3DSketchExport_graph.json")
    .then((response) => {
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return response.text();
    })
    .then((text) => loadSketchData(text, "3DSketchExport_graph.json"))
    .catch((err) => {
      statusEl.textContent = "No default graph loaded (use JSON file picker)";
      console.warn("Default graph load failed:", err);
    });

  viewSelect.addEventListener("change", () => {
    const is3d = viewSelect.value === "p3d";
    fovLabel.style.display = is3d ? "inline-flex" : "none";
    render();
  });

  fovEl.addEventListener("input", () => {
    cam.fovDeg = Number(fovEl.value);
    fovValEl.textContent = String(cam.fovDeg);
    render();
  });

  // --- Helpers to get geometry in a unified way ---
  function iterAllPoints(cb) {
    if (!mode) return;
    if (mode === "segments" && segments) {
      for (const s of segments) { cb(s.Start); cb(s.End); }
    } else if (mode === "graph" && graph) {
      for (const n of graph.nodes) cb(n);
    }
  }

  function getBounds() {
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
    let count = 0;
    iterAllPoints(p => {
      const x = p[0], y = p[1], z = p[2];
      if (x < minX) minX = x; if (x > maxX) maxX = x;
      if (y < minY) minY = y; if (y > maxY) maxY = y;
      if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
      count++;
    });
    if (!count) return null;
    return { minX, minY, minZ, maxX, maxY, maxZ };
  }

  function fitCameraToData() {
    const b = getBounds();
    if (!b) return;
    const cx = (b.minX + b.maxX) / 2;
    const cy = (b.minY + b.maxY) / 2;
    const cz = (b.minZ + b.maxZ) / 2;
    cam.target = [cx, cy, cz];

    const dx = b.maxX - b.minX;
    const dy = b.maxY - b.minY;
    const dz = b.maxZ - b.minZ;
    const radius = 0.5 * Math.hypot(dx, dy, dz) || 1;

    // Place camera so object fits in view at current FOV.
    const fov = (cam.fovDeg * Math.PI) / 180;
    const pad = 1.25;
    cam.dist = radius * pad / Math.tan(fov / 2);

    // Pan scale roughly proportional to scene size.
    cam.panScale = radius / 400;
  }

  // --- 3D camera math ---
  function getCameraBasis() {
    // Orbit camera around target.
    const cp = Math.cos(cam.pitch), sp = Math.sin(cam.pitch);
    const cy = Math.cos(cam.yaw), sy = Math.sin(cam.yaw);

    // Camera position in world (spherical around target).
    const offset = [
      cam.dist * cp * sy,
      cam.dist * sp,
      cam.dist * cp * cy,
    ];
    const pos = add(cam.target, offset);

    const forward = norm(sub(cam.target, pos));
    const worldUp = [0, 1, 0];

    // If forward is nearly parallel to up, nudge pitch to avoid NaNs.
    let right = cross(worldUp, forward);
    if (len(right) < 1e-6) {
      // pick a different up in this pathological case
      right = cross([1, 0, 0], forward);
    }
    right = norm(right);
    const up = norm(cross(forward, right));

    return { pos, forward, right, up };
  }

  function projectPerspective(p, basis, width, height) {
    // p in world -> camera space
    const rel = sub(p, basis.pos);
    const x = dot(rel, basis.right);
    const y = dot(rel, basis.up);
    const z = dot(rel, basis.forward); // z > 0 is in front

    const near = 1e-4;
    if (z <= near) return null;

    // This is exactly the idea you suggested: x' = x/z, y' = y/z.
    // We just scale by focal length to map into pixels.
    const fov = (cam.fovDeg * Math.PI) / 180;
    const f = 0.5 * Math.min(width, height) / Math.tan(fov / 2);

    const sx = (x / z) * f + width / 2;
    const sy = height / 2 - (y / z) * f;

    return { sx, sy, z };
  }

  // --- Interaction (3D orbit/pan/zoom) ---
  let dragging = false;
  let dragMode = "orbit"; // or "pan"
  let lastX = 0, lastY = 0;

  canvas.addEventListener("mousedown", (e) => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
    dragMode = e.shiftKey ? "pan" : "orbit";
    canvas.focus?.();
  });

  window.addEventListener("mouseup", () => { dragging = false; });
  window.addEventListener("mouseleave", () => { dragging = false; });

  window.addEventListener("mousemove", (e) => {
    if (!dragging) return;
    if (viewSelect.value !== "p3d") return;

    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    if (dragMode === "orbit") {
      cam.yaw += dx * 0.005;
      cam.pitch += dy * 0.005;
      cam.pitch = clamp(cam.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01);
      render();
    } else {
      // Pan target along camera right/up.
      const basis = getCameraBasis();
      cam.target = add(cam.target, add(mul(basis.right, -dx * cam.panScale), mul(basis.up, dy * cam.panScale)));
      render();
    }
  });

  canvas.addEventListener("wheel", (e) => {
    if (viewSelect.value !== "p3d") return;
    e.preventDefault();

    // Zoom (dolly). Wheel delta is typically ~100 per notch.
    const zoomFactor = Math.exp(e.deltaY * 0.001);
    cam.dist *= zoomFactor;
    cam.dist = clamp(cam.dist, 1e-4, 1e9);
    render();
  }, { passive: false });

  window.addEventListener("keydown", (e) => {
    if (e.key === "r" || e.key === "R") {
      fitCameraToData();
      render();
    }
  });

  // --- Rendering ---
  function renderEmptyCrosshair() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.moveTo(0, canvas.height / 2);
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();
  }

  function render2D(view) {
    let ix, iy;
    if (view === "xy") { ix = 0; iy = 1; }
    else if (view === "xz") { ix = 0; iy = 2; }
    else { ix = 1; iy = 2; }

    const width = canvas.width;
    const height = canvas.height;

    // Bounds
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    if (mode === "segments" && segments) {
      for (const seg of segments) {
        const sx = seg.Start[ix];
        const sy = seg.Start[iy];
        const ex = seg.End[ix];
        const ey = seg.End[iy];
        minX = Math.min(minX, sx, ex);
        maxX = Math.max(maxX, sx, ex);
        minY = Math.min(minY, sy, ey);
        maxY = Math.max(maxY, sy, ey);
      }
    } else if (mode === "graph" && graph) {
      for (const n of graph.nodes) {
        const x = n[ix];
        const y = n[iy];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }

    if (!isFinite(minX) || !isFinite(minY)) return;

    // Pad + scale
    const padFactor = 0.06;
    const dx = maxX - minX || 1;
    const dy = maxY - minY || 1;
    minX -= dx * padFactor;
    maxX += dx * padFactor;
    minY -= dy * padFactor;
    maxY += dy * padFactor;

    const scaleX = width / (maxX - minX || 1);
    const scaleY = height / (maxY - minY || 1);
    const scale = 0.95 * Math.min(scaleX, scaleY);

    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    function worldToScreen(x, y) {
      const sx = (x - centerX) * scale + width / 2;
      const sy = height / 2 - (y - centerY) * scale;
      return [sx, sy];
    }

    renderEmptyCrosshair();

    if (mode === "segments" && segments) {
      ctx.strokeStyle = "#00ff88";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (const seg of segments) {
        const [sx, sy] = worldToScreen(seg.Start[ix], seg.Start[iy]);
        const [ex, ey] = worldToScreen(seg.End[ix], seg.End[iy]);
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
      }
      ctx.stroke();
    } else if (mode === "graph" && graph) {
      const { nodes, beams } = graph;
      const projected = nodes.map(n => worldToScreen(n[ix], n[iy]));

      function strokeBeams(filterFn, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (const b of beams) {
          if (!filterFn(b)) continue;
          const ni = projected[b.I];
          const nj = projected[b.J];
          if (!ni || !nj) continue;
          ctx.moveTo(ni[0], ni[1]);
          ctx.lineTo(nj[0], nj[1]);
        }
        ctx.stroke();
      }

      strokeBeams(b => (b.Type || b.type || "").toLowerCase() === "line",   "#00ff88");
      strokeBeams(b => (b.Type || b.type || "").toLowerCase() === "spline", "#ffaa33");
      strokeBeams(b => (b.Type || b.type || "").toLowerCase() === "arc",    "#33ddff");
      strokeBeams(b => {
        const t = (b.Type || b.type || "").toLowerCase();
        return t !== "line" && t !== "spline" && t !== "arc";
      }, "#888888");

      // nodes on top
      ctx.fillStyle = "#ffffff";
      for (const [x, y] of projected) {
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  function render3D() {
    renderEmptyCrosshair();
    if (!mode) return;

    const width = canvas.width;
    const height = canvas.height;
    const basis = getCameraBasis();

    // Project all nodes (graph) or all endpoints (segments).
    let nodeProj = null; // for graph: index -> {sx,sy,z}

    if (mode === "graph" && graph) {
      nodeProj = graph.nodes.map(p => projectPerspective(p, basis, width, height));

      // Sort beams by depth (far -> near) so overlaps look nicer.
      const beamsSorted = [...graph.beams].sort((a, b) => {
        const pa0 = nodeProj[a.I], pa1 = nodeProj[a.J];
        const pb0 = nodeProj[b.I], pb1 = nodeProj[b.J];
        const za = pa0 && pa1 ? (pa0.z + pa1.z) * 0.5 : Infinity;
        const zb = pb0 && pb1 ? (pb0.z + pb1.z) * 0.5 : Infinity;
        return zb - za; // draw far first
      });

      function colorForBeam(b) {
        const t = (b.Type || b.type || "").toLowerCase();
        if (t === "line") return "#00ff88";
        if (t === "spline") return "#ffaa33";
        if (t === "arc") return "#33ddff";
        return "#888888";
      }

      // Beams
      ctx.lineWidth = 2;
      for (const b of beamsSorted) {
        const a = nodeProj[b.I];
        const c = nodeProj[b.J];
        if (!a || !c) continue;
        ctx.strokeStyle = colorForBeam(b);
        ctx.beginPath();
        ctx.moveTo(a.sx, a.sy);
        ctx.lineTo(c.sx, c.sy);
        ctx.stroke();
      }

      // Nodes: draw near last; size slightly based on depth.
      const nodesSorted = graph.nodes.map((_, i) => i).sort((i, j) => {
        const ai = nodeProj[i], aj = nodeProj[j];
        const zi = ai ? ai.z : Infinity;
        const zj = aj ? aj.z : Infinity;
        return zj - zi;
      });

      ctx.fillStyle = "#ffffff";
      for (const i of nodesSorted) {
        const p = nodeProj[i];
        if (!p) continue;
        // Size ranges roughly 2..4 depending on depth.
        const r = clamp(4 - Math.log10(p.z + 1) * 1.2, 2.0, 4.0);
        ctx.beginPath();
        ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    if (mode === "segments" && segments) {
      // Segments are already edges; we just project endpoints.
      // Sort by avg depth.
      const items = segments.map(seg => {
        const a = projectPerspective(seg.Start, basis, width, height);
        const b = projectPerspective(seg.End, basis, width, height);
        const z = a && b ? (a.z + b.z) * 0.5 : Infinity;
        return { seg, a, b, z };
      }).sort((A, B) => B.z - A.z);

      ctx.strokeStyle = "#00ff88";
      ctx.lineWidth = 2;
      for (const it of items) {
        if (!it.a || !it.b) continue;
        ctx.beginPath();
        ctx.moveTo(it.a.sx, it.a.sy);
        ctx.lineTo(it.b.sx, it.b.sy);
        ctx.stroke();
      }
    }

    // Subtle "ground" axes at target (optional).
    // (Kept minimal; comment out if you don't want it.)
    const t = cam.target;
    const axes = [
      { a: t, b: add(t, [1,0,0]) },
      { a: t, b: add(t, [0,1,0]) },
      { a: t, b: add(t, [0,0,1]) },
    ];
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.35;
    for (const ax of axes) {
      const pa = projectPerspective(ax.a, basis, width, height);
      const pb = projectPerspective(ax.b, basis, width, height);
      if (!pa || !pb) continue;
      ctx.strokeStyle = "#666";
      ctx.beginPath();
      ctx.moveTo(pa.sx, pa.sy);
      ctx.lineTo(pb.sx, pb.sy);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function render() {
    if (canvas.width === 0 || canvas.height === 0) return;
    if (!mode) {
      renderEmptyCrosshair();
      return;
    }

    const view = viewSelect.value;
    if (view === "p3d") render3D();
    else render2D(view);
  }

  // Initial layout
  resizeCanvas();
  </script>
</body>
</html>


